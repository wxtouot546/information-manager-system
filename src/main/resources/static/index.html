<!DOCTYPE html>
<html lang="en">
<head>
    <title>lucene教程 lucene原理</title>
    <meta name="keywords" content="lucene,lucene入门,lucene教程,lucene视频,lucene视频教程,lucene原理,搜索引擎教程" />
    <meta name="description" content="lucene,lucene入门,lucene教程,lucene视频,lucene视频教程,lucene原理,搜索引擎教程" />

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="./css/article_details_template.css">
</head>
<body>
    <div id="article_details">
        <div class="header">
            <div class="left_nav">
                <a href="#" class="nav_li">学习</a>
                <a href="#" class="nav_li">开发</a>
                <a href="#" class="nav_li">社区</a>
            </div>
            <div class="rigth_nav">
                <a href="#" class="nav_li">图片</a>
                <a href="#" class="nav_li">文字</a>
            </div>
        </div>
        <div class="link_content">
			<div class="Anchor_link">
                <div class="Anchor_content">
                    <div class="title"><a href="#lucenejiaocheng">lucene教程</a></div>
                    <label class="line"></label>
                    <a href="#qianyan" class="link_li active">前言</a>
                    <a href="#shenmeshihoushiyongsousuoyinqing" class="link_li">什么时候应该考虑使用搜索引擎?</a>
                    <a href="#luceneshishenme" class="link_li">lucene是什么</a>
                    <a href="#lucenemysqlqubie" class="link_li">lucene、mysql、oracle的区别？</a>
                    <a href="#solrelasticsearchshishenme" class="link_li">Solr是什么？ElasticSearch是什么？</a>
                    <a href="#lucenesolrqubie" class="link_li">lucene与solr(elasticsearch)的区别？</a>
                    <a href="#solrelasticsearchqubie" class="link_li">solr与elasticsearch的区别？</a>
                    <a href="#luceneyuanli" class="link_li">lucene原理是什么？</a>
                    <a href="#lucenekuaisujiansuo" class="link_li">第一个问题: lucene快速检索的原理是什么？</a>
                    <a href="#lucenesousuoxiaoguo" class="link_li">第二个问题: lucene的搜索效果为什么好？</a>
                    <a href="#jieshu" class="link_li">结束语</a>
                </div>
			</div>
			<div class="content">
				<h1><a name="lucenejiaocheng">lucene教程</a></h1>
                <h1><a name="qianyan">前言</a></h1>
                <p>我是邢开春，有过几年搜索引擎开发的经验，现在搞了一个网站，一是交流分享，二是希望利用自己的工作经验赚取一些外快。现在已将自己多年搜索引擎的经验做成了一套教程（包含lucene、solr、elasticsearch），这套教程从入门使用到深入原理，面面俱到，可以帮助初学者快速入门，帮助使用者务实基础。本人的课程(博客文章、视频教程等)力求在知识上直击本质。</p>
                <h1><a name="shenmeshihoushiyongsousuoyinqing">什么时候应该考虑使用搜索引擎?</a></h1>
                <h2>第一点：有搜索功能的需求</h2>
                <p>想为App、网站添加类似”百度搜索的服务”搜索自家资源；想为用户提供类似”百度搜索的服务”搜索自家资源。</p>
                <h2>第二点: 对搜索速度有要求</h2>
                <p>有时会遇到mysql数据库搜索的速度过慢。举一个例子，使用数据库提供的like ‘%关键词%’功能，在一亿篇文档中检索，将会耗时几小时才能查找出结果。而搜索引擎则能做到几十毫秒查询到结果。</p>
                <h>【mysql的like查询为什么慢】</h>
                <p>mysql数据库的like查询会顺序扫描每一个数据记录，所谓顺序扫描，就是一个记录一个记录的查询扫描，对于每一个记录，从头看到尾，一个字符一个字符的检测是否包含被查询字符串。假设每扫描一万记录耗时一秒，扫描一亿条记录，约耗时一万秒，约三小时。</p>
                <h2>第三点：对搜索结果的质量有要求</h2>
                <p>假设一电商平台，用户搜索关键词”华为手机”搜出5000个商品。因为商品数据太多，可以用分页技术把数据展示给用户，但是一般用户也就查看前三页，总计几十个的商品。这说明只有极小一部分商品数据才能被用户看到，而5000个商品可能只有一小部分可能被用户感兴趣，如何尽量让用户可能感兴趣的商品排在前面，从而让用户看到他们可能感兴趣的商品？</p>
                <p>如果排在前面展示的商品都是用户不感兴趣的，而用户感兴趣的商品都展示在页码靠后的页面，那用户体验太糟糕了。[说句题外话，对于不同用户，由于身份，阅历不同，对待同一商品的满意程度是不一致的。这是更深层次的搜索功能。]。</p>
                <p>Lucene会通过评分模型为搜索词与每一个被搜索出来商品一一计算一个相关度，相关度越大说明搜索词与商品之间的关系越大。然后商品按照与搜索词的相关度排序，和搜索词相关度大的排在前面，越靠前的商品与搜索词相关度越高，关系越大，而关键词又是用户输入的，自然靠前的商品越有可能是用户感兴趣的商品。</p>
                <h1><a name="luceneshishenme">lucene是什么</a></h1>
                <p>Lucene是一款开源的、高性能的、可拓展的信息检索Java工具库(也就是说lucene是提供搜索功能的Java jar包)。具体是下图的东西，也可以下载下来看一眼是什么。(下载链接)。将lucene引入Java项目中，你可以利用它做出类似百度、google提供的搜索服务。</p>
                <p><br></p>
                <p>lucene单纯的是一个jar包。它仅仅只提供搜索最核心的的开发接口【后面有讲:创建索引与利用索引进行搜索】，说直白点，它只是一个java语言的开发工具jar包。它没有用户操作界面，只支持Java编程语言开发，缺少其它编程语言的sdk[链接]，不提供分布式搜索服务。</p>
                <p><br></p>
                <h1><a name="lucenemysqlqubie">lucene、mysql、oracle的区别？</a></h1>
                <p>lucene是搜索引擎，mysql、oracle是关系型数据库，问lucene与mysql的区别，不如问搜索引擎与关系型数据库的区别</p>
                <p><br></p>
                <table class="table table-bordered">
                    <tbody>
                    <tr>
                        <td><br></td>
                        <td>搜索引擎<br></td>
                        <td>关系型数据库<br></td>
                    </tr>
                    <tr>
                        <td>搜索速度<br></td>
                        <td>亿级数据量，可以保持在几十毫秒内查询出结果<br></td>
                        <td>亿级数据量，不能很好支持查询like查询<br></td>
                    </tr>
                    <tr>
                        <td>搜索质量<br></td>
                        <td>搜索质量高。有评分模型，使得搜索结果中与搜索词相关度较高的结果排前面返回<br></td>
                        <td>搜索质量较差。数据库一般不关注搜索质量。数据库着重于对数据资源的管理。具体来说是增删改查, ACID。一般，数据库提供按照数字大小，字符编码进行排序的功能。<br></td>
                    </tr>
                    <tr>
                        <td>维护数据与数据之间的关系的能力<br></td>
                        <td>弱<br></td>
                        <td>专业<br></td>
                    </tr>
                    </tbody>
                </table>
                <h1><a name="solrelasticsearchshishenme">Solr是什么？ElasticSearch是什么？</a></h1>
                <p>solr是什么？(链接)elasticsearch是什么？(链接)(视频)</p>
                <p>之所以把solr与elasticsearch放在一起说，是因为它们的底层都是lucene，再lucene提供的功能上进行了二次开发，附加了众多的功能，是搜索引擎的一个完整解决方案，属于企业级[我理解的企业级，开箱即用]的搜索引擎平台。它们都提供用户操作控制台；提供RESTful风格编程接口，也就是说它可以被任何编程语言使用；提供分布式搜索功能，不用再担心数据增多。</p>
                <p>另外说一句，它们的关系好比是oracle与mysql(它们都是关系型数据库)。</p>
                <h1><a name="lucenesolrqubie">lucene与solr(elasticsearch)的区别？</a></h1>
                <p><br></p>
                <table class="table table-bordered">
                    <tbody>
                    <tr>
                        <td><br></td>
                        <td>Lucene<span style="white-space:pre">	</span><br></td>
                        <td>Solr/Elasticsearch<br></td>
                    </tr>
                    <tr>
                        <td>是Java jar包<br></td>
                        <td>是<br></td>
                        <td>不是<br></td>
                    </tr>
                    <tr>
                        <td>是Web应用<br></td>
                        <td>不是<br></td>
                        <td>是<br></td>
                    </tr>
                    <tr>
                        <td>提供用户操作控制台<br></td>
                        <td>不提供<br></td>
                        <td>提供<br></td>
                    </tr>
                    <tr>
                        <td>提供RESTful风格编程接口<br></td>
                        <td>不提供<br></td>
                        <td>提供<br></td>
                    </tr>
                    <tr>
                        <td>提供分布式搜索功能<br></td>
                        <td>不提供<br></td>
                        <td>提供<br></td>
                    </tr>
                    </tbody>
                </table>
                <p>既然如上所说，solr/Elasticsearch功能比lucene强大太多，我还需要学习lucene吗？</p>
                <p>这里可以给肯定的答复，如果只满足于简单使用搜索引擎这一初级阶段，跳过lucene，直接学习使用Solr/ElasticSearch也是可以的。但是想要得心应手，必定要深入学习lucene，lucene是高楼大厦的地基，地基打的好，楼房才能又高又稳。</p>
                <p>另外，也有lucene适用，Solr/ElasticSearch反而不适用的场景。</p>
                <p>例如:为手机文件管理app提供，根据搜索词，搜索内容包含搜索词的文件列表。这里用内嵌的jar的方式开发反而更为恰当。如果用Solr、ElasticSearch开发，你需要搭建Solr、ElasticSearch服务，我们不能在手机用户手机上搭建服务，需要在服务器上搭建，用户的数据需要上传到服务器端，才能为用户提供服务，特别繁杂。</p>
                <p>我的意见是一定要深入学习lucene，但在使用选择上尽量使用Solr/ElasticSearch，能不用Lucene就别单独使用Lucene。单说一点，随着数据量上升，单机已经承受不住性能，你需要为lucene做二次开发，使其支持分布式。而Solr/ElasticSearch作为成熟的企业级搜索引擎解决方案，早已经提供了分布式。</p>
                <h1><a name="solrelasticsearchqubie">solr与elasticsearch的区别？</a></h1>
                <p>既然solr与elasticsearch都是企业级的搜索平台，它们的相同点有很多: 它们的底层都是lucene，它们都是企业级搜索平台，它们都提供分布式搜索功能，都能轻易处理亿级的数据量，都提供实时搜索功能......</p>
                <p>那它们有什么区别呢？据我的观察，它们最大的区别是生态。solr是apache开源的软件，它开源，完全免费的企业级搜索平台。而elasticsearc是公司企业在维护推广，它部分产品收费，同时企业围绕着elasticsearch推出了一套完善的数据分析框架，也就是大名鼎鼎的ELK。</p>
                <p><br></p>
                <table class="table table-bordered">
                    <tbody>
                    <tr>
                        <td><br></td>
                        <td>Solr<br></td>
                        <td>ElasticSearch<br></td>
                    </tr>
                    <tr>
                        <td>企业级搜索平台<br></td>
                        <td>是<br></td>
                        <td>是<br></td>
                    </tr>
                    <tr>
                        <td>是Web应用<br></td>
                        <td>是<br></td>
                        <td>是<br></td>
                    </tr>
                    <tr>
                        <td>提供用户操作控制台<br></td>
                        <td>提供<br></td>
                        <td>提供<br></td>
                    </tr>
                    <tr>
                        <td>提供RESTful风格编程<br></td>
                        <td>提供<br></td>
                        <td>提供<br></td>
                    </tr>
                    <tr>
                        <td>提供分布式搜索功能<br></td>
                        <td>提供<br></td>
                        <td>提供<br></td>
                    </tr>
                    <tr>
                        <td>提供安全认证<br></td>
                        <td>提供<br></td>
                        <td>提供<br></td>
                    </tr>
                    </tbody>
                </table>
                <br><table class="table table-bordered">
                <tbody>
                <tr>
                    <td></td>
                    <td>Solr</td>
                    <td>ElasticSearch<br></td>
                </tr>
                <tr>
                    <td>组织<br></td>
                    <td>大名鼎鼎的apache<br></td>
                    <td>elasticsearc公司<br></td>
                </tr>
                <tr>
                    <td>开源<br></td>
                    <td>完全开源<br></td>
                    <td>部分开源<br></td>
                </tr>
                <tr>
                    <td>产品收费<br></td>
                    <td>完全免费<br></td>
                    <td>部分收费<br></td>
                </tr>
                <tr>
                    <td>生态<br></td>
                    <td>Lucene/Solr<br></td>
                    <td>ELK等<br></td>
                </tr>
                </tbody>
            </table>
                <h1><a name="luceneyuanli">lucene原理是什么？</a></h1>
                <p>这个问题问的不够准确，一般人其实想问的问题包含两个:</p>
                <p>一是lucene快速检索的原理是什么？</p>
                <p>二是lucene的搜索效果为什么好？</p>
                <h1><a name="lucenekuaisujiansuo">第一个问题: lucene快速检索的原理是什么？</a></h1>
                <h2>索引的概念</h2>
                <h3>假设，我们有一个问题，如何在一亿个从小到大排序好的有序数据集中查找一个特定的数存不存在？</h3>
                <p>基本原理是：首先在有序的数字中找到中值(最中间的那个数的值)，将要查找的目标与中值进行比较，如果目标等于中值，则数据集中存在要查找的数；如果目标小于中值，若目标存在，则一定在前半部分数据中(这样，我们待查找的数据范围缩小了一半，在一亿条数据中查找和在五千万条数据中查找，差别还是蛮大的)，如果目标大于中值，则在后半部分查找；</p>
                <p>如何在剩下的五千万条中查找呢？</p>
                <p>同样的方法，先找这五千万条数据中的中值，如果目标等于中值，则数据集中存在要查找的数；如果目标小于中值，则在前半部分找；如果目标大于中值，则在后半部分找。</p>
                <p>如何在剩下的二千五百万条数据中查找呢？</p>
                <p>同样的方法，先找中值，如果目标等于中值，则数据集中存在要查找的数；如果目标小于中值，则在前半部分找；如果目标大于中值，则在后半部分找。</p>
                <p>如何在剩下的一千二百五十万条数据中查找呢？</p>
                <p>以此类推，直到找到目标为止。</p>
                <p>二分查找大大降低了比较次数，二分查找的时间复杂度为：，即。</p>
                <p>用二分查找，至多查询27次，就可确定一亿个有序的数中是否包含某个数。</p>
                <h3>具体案例</h3>
                <p>假设我们要在 1，2，7，15，18，30，35，41中查找7，上图所示，则查找步骤为：</p>
                <p><img src="http://47.94.230.44:80/File/FileDownload?fileId=417e21a7-9a8a-4faf-abef-b812b2df4315" style="width: 679px;"><br></p>
                <p>第一次查询:在 1，2，7，15，18，30，35，41中查找7。</p>
                <p>首先找到中值：中值为15（下标= (0+7)/2），将7与15进行比较，发现7比15小，继续在前面部分[1，2，7，15]找；</p>
                <p>第二次查询: 在[1，2，7，15]中查找7。</p>
                <p>首先找到中值：中值为2（下标= (0+3)/2），将7与2进行比较，发现7比2大，继续在后面部分[7，15]找；</p>
                <p>第二次查询: 在[7，15]中查找7。</p>
                <p>首先找到中值：中值为7（下标= (0+1)/2），将7与7进行比较，发现相等，代表我们已经查找到7了。查询结束。</p>
                <p><br></p>
                <h3>假设，我们有一个问题，如何在一亿个无序的数据集中查找一个特定的数存不存在？</h3>
                <p>因为是无序、毫无规则，最容易想到，顺序的拿数据集中的每一个数字与待查询的数字比较。虽然可以解决这个问题，但是这最差的情况下可能需要比较一亿次。</p>
                <p>换一种思路:如果我把无序的数据集整理成有序的数据集，则最多27次就可以查询到结果了。</p>
                <p>新的做法:我们先用无序的数字集生成一份有序的数据集[这份有序的数据集，有个专业术语叫做索引]。然后我们在索引上寻找待查询的数字。</p>
                <h3>【补充一下:专业术语】</h3>
                <p>索引作为名词时: 索引是一种拥有特定数据结构【上面的例子，指的是”有序的”这种结构】的数据。</p>
                <p>”有序的”这种结构是【索引类型】的一种。另外，我们熟知的索引类型还有B Tree索引、红黑树索引、Hash索引等</p>
                <p>把无序的数据集整理成有序的数据集的动作被称为[创建索引、生成索引]。</p>
                <p>索引还有一种意思，作为动词:代表用…生成索引[名词]的意思。</p>
                <p>把无序的数据集索引一下。【含义，用[无序的数字集]生成了一份索引[名词]】</p>
                <p>索引文档。【含义，用[文档]生成了一份索引[名词]】</p>
                <p><br></p>
                <p>由于无序的数据查找数字效率太低，我们创建了一份可以进行快速查找数据的有着特定数据结构的数据【索引】，在进行数字查找的时候，我们是在索引上进行查找的，所以查找速度提升了成千上万倍。</p>
                <p><br></p>
                <h4>同时我们可以归纳出索引的使用方式:</h4>
                <p>①创建索引</p>
                <p>②利用索引进行检索</p>
                <p><br></p>
                <h4>索引的优缺点:</h4>
                <p>相比直接在原始数据做查询，在索引上做查询速度更快。如果我们需要实时查询，直接在原始数据上操作已经不能够满足实时要求，则需要创建适合的索引。</p>
                <p>而且创建索引是一次操作，而无论多少次查询都可以使用同一份索引。</p>
                <p>虽然建立这个索引的过程比较耗资源，但是如果我的查询次数比较多，这个前置的消耗可以被认为是值得的。</p>
                <p>另外原始数据有改变【增加或是减少】，也需要维护相对应的索引保持一致，所以维护索引的成本也比较高。</p>
                <p><br></p>
                <h3>假设，我们有一个问题，如何在一亿篇文章中查找包含’lucene’的文章？</h3>
                <h4>顺序扫描</h4>
                <p>一种传统的做法叫做顺序扫描法：所谓顺序扫描，比如要找【内容包含某一个字符串】的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件，最终找出所有【内容包含某一个字符串】的文件。</p>
                <p>对于小批量的文件，这种方法还是很直接，很方便的。但是对于大批量的文件，这种方法就很慢了。</p>
                <p><br></p>
                <h4>使用索引</h4>
                <p>我们能不能仿照【查找无序数字集中是否存在某个数】时的思维，先创建一种【拥有方便查找”关键词”被哪些文章包含的数据结构的数据】索引，然后利用索引进行搜索，从而加快搜索速度。</p>
                <p>我们的目标是创造一种适合查找”关键词”被哪些文章包含的数据结构。那好，我就直接创建一种关键词到文档ID列表的映射的索引，这样给出关键词，我就能随即找到文档ID列表，不就完美解决问题了吗?</p>
                <p>具体案例</p>
                <p>文档1:邢开春录制的搜索引擎视频教程通俗易懂</p>
                <p>文档1可以划分出关键词(/邢开春/录制/的/搜索引擎/视频教程/通俗易懂/)</p>
                <p><img src="http://47.94.230.44:80/File/FileDownload?fileId=2ed3c11e-6016-4c97-9477-d2c7351819be" style="width: 691.699px; height: 509.273px;"><br></p>
                <p>文档2:搜索引擎视频教程在www.xingkaichun.com下载</p>
                <p>文档2可以划分出关键词(/搜索引擎/视频教程/在/www.xingkaichun.com/下载/)</p>
                <p><img src="http://47.94.230.44:80/File/FileDownload?fileId=a39439a8-11a9-44be-9d56-e020a5311077" style="width: 918px;"><br></p>
                <p>假设查找’视频教程’出现在哪些文档中。</p>
                <p>关键字’视频教程’的那一行的文档列表就是’视频教程’出现的所有文档。</p>
                <p><img src="http://47.94.230.44:80/File/FileDownload?fileId=bae32bf8-b0b4-4571-adc8-d67e5f73c4ba" style="width: 877px;"><br></p>
                <p>可以发现在这种关键词到文档列表的结构基础上，轻而易举就可以查到某个关键词被哪些文档包含。<br></p>
                <p>以上所说的【关键词到文档列表ID映射】是一种特别的索引类型，专业术语叫做倒排索引【倒着排列的索引】或全文索引。</p>
                <p>Lucene之所以搜索快速最重要的原因就是使用了倒排索引。除此之外，众所周知，CPU速度远远大于磁盘IO速度。lucene里大量使用压缩技术(磁盘压缩，内存压缩)，减少磁盘IO开销，充分利用CPU的性能以提高程序性能。【视频里讲解了作者的理解】</p>
                <p><br></p>
                <p>这里为了充分理解倒排索引，将补充一些概念，既然有倒排索引？试想，是否存在与之相对应的正排索引？</p>
                <p>全文索引，又称倒排索引、反向索引、inverted index，与之相对应的是正排索引、正向索引、forward index。</p>
                <p>正排索引是什么：无论课本，杂志，还是报纸，它们都拥有一个目录。假如我们想看某篇文章，通过目录，我们可以看到这篇文章所在的页面，而不是笨拙的一页页的去看是否是这篇文章。这里，目录就是一个索引【思考：它是什么内容的索引？这样结构的索引为了什么？】。</p>
                <p>其实，书籍可以看做两部分组成，一部分是目录索引，另一部分是去掉目录、剩余的实际的内容。</p>
                <p>目录有文章标题到文章位置(页码)映射的特殊数据结构，可以帮助我们去了解书本中所有文章，如果喜欢文章，通过文章关联的页码直接定位文章所在书本的位置。</p>
                <p>书籍的目录即是相对书籍中的文章的一份索引信息。像目录这种索引，因为通过文章名称(文章名称相当于文章的唯一标识)去找文章，是一个很自然的操作，所以目录这种索引，被称为正向索引[正方向的索引]、正排索引[正方向排列的索引]。</p>
                <p><br></p>
                <p>倒排索引是什么：与正排索引相对立，如果我想通过文章中的一部分内容去找这篇文章（例如：'邢开春'这个姓名出现在哪些文章中？），就是一个反向操作了[由部分内容找整体]，不那么自然了，而且查找速度会特别慢（一本几百页的书籍，如果不做任何处理的话，想找到这个网址在哪里,你需要一行行去查找匹配，查找效率自然很慢）。好在我们可以针对书籍先做处理，找出所有出现'邢开春'的文章，建立一个从'邢开春'到文章的映射，通过映射，还是可以快速检索'邢开春'在哪篇文章之中出现，这种不太自然的映射结构，被称为倒排索引[倒着排列的索引]、全文索引、反向索引[反方向的索引]。</p>
                <p><br></p>
                <p>倒排索引应该如何使用？</p>
                <p>上面我们归纳了索引的使用方式:</p>
                <p>①创建索引</p>
                <p>②利用索引进行检索</p>
                <p><br></p>
                <p>同理，倒排索引是索引的一种类型，当然它的使用方式也应当是</p>
                <p>①建立索引:为原文档创建索引。&nbsp;</p>
                <p>②检索：利用索引进行检索。</p>
                <p><br></p>
                <p>把搜索引擎(lucene/solr/elasticsearch)使用方式用流程图表示</p>
                <p><img src="http://47.94.230.44:80/File/FileDownload?fileId=e2490b5a-0cec-4e9e-b6ce-e4bb3bd26ead" style="width: 692px;"><br></p>
                <h3>[搜索引擎相关概念]</h3>
                <p>文档1:邢开春录制的搜索引擎视频教程通俗易懂</p>
                <p>文档1可以划分出关键词(/邢开春/录制/的/搜索引擎/视频教程/通俗易懂/)</p>
                <p>同学们有没有注意到这里我把文章1切分了很多关键词，这个动作的专业术语叫做分词[把一句话划分为一个个独立的有意义的词汇单元]。负责分词的类在lucene源码里被称为Analyzer[分词器]。而这些个独立的有意义的词汇单元在lucene源码里被称为Term。以后我们用Term代称被分词后的一个个词汇单元。</p>
                <p>分词是搜索引擎里特别重要的技术。分词出来的词语是倒排索引里的词汇单元。Term匹配时，必须完全相等。而搜索就是利用的倒排索引。所以如果Term没有被分出来，就会搜索不到。</p>
                <p>用文档1的倒排索引(/邢开春/录制/的/搜索引擎/视频教程/通俗易懂/)搜索’教程’这两个字就搜索不到结果，就是因为倒排索引里没有’教程’这个Term。</p>
                <p>注意Term匹配的时候，字符串完全相等才能算匹配的上。特别注意大小写、空格等匹配，这些也需要完全相等，不然匹配不上。</p>
                <h5>停用词</h5>
                <p>进一步说，在中文文章里，几乎每一篇文章都会出现’的’、’了’等Term，思考一下，我们真的需要为这些Term创建倒排表吗？’的’、’了’，这些term本身也没什么特殊含义，另外每一篇文章都会出现这些Term，也就相当于用’的’、’了’搜索时，几乎每一篇文章都会匹配，既然所有文章都被匹配了，还搜它干什么。我们希望搜索获取有用信息，而不是大量信息。分词器在分词的时候可不是单单的划分Term，它还可以对分词出来的Term进一步处理，如过滤掉一部分词语。这里希望被分词器过滤的Term被称为停用词。</p>
                <p><br></p>
                <p>还有一些违法犯罪的Term[词汇有罪哈，例如一些历史事件、一些不可描述的词汇可能出现网站就被河蟹掉了]，我们希望屏蔽搜索这些词，一种方法就是不为这些Term创建倒排表。分词器在分词的时候可不是单单的划分Term，它还可以对分词出来的Term进一步处理，如过滤掉一部分词语。</p>
                <p>文档1:邢开春录制的搜索引擎视频教程通俗易懂</p>
                <p>‘的’是一个停用词，分词器经过分词分析处理后的分词结果如下。</p>
                <p>文档1可以划分出关键词(/邢开春/录制/搜索引擎/视频教程/通俗易懂/)</p>
                <h5>同义词</h5>
                <p>还有同义词，只要在倒排索引里创建同义词的倒排表。搜索的时候，就可以搜索到同义词。[这只是做同义词功能的一种方式]。分词器在分词的时候可不是单单的划分Term，它还可以对分词出来的Term进一步处理，如新增一部分Term。</p>
                <p>文档1:邢开春录制的搜索引擎视频教程通俗易懂</p>
                <p>简单明了时通俗易懂的近义词，分词器经过分词分析处理后的分词结果如下。</p>
                <p>文档1可以划分出关键词(/邢开春/录制/搜索引擎/视频教程/通俗易懂/简单明了/)</p>
                <h5>简繁搜索</h5>
                <p>/邢开春/邢開春/录制/錄製/搜索引擎/搜尋引擎/视频教程/視頻教程/通俗易懂/通俗易懂/</p>
                <h5>拼音搜索</h5>
                <p>/邢开春/xingkaichun/录制/luzhi/搜索引擎/sousuoyinqing/视频教程/shipinjiaocheng/通俗易懂/tongsuyidong/</p>
                <p>.....</p>
                <p>以上可以看到分词器十分重要，众多搜索功能的实现都与它息息相关。做搜索引擎的同学，最好要理解分词器，还需要看分词组件的源码，才好彻底掌握，才好对分词器的使用得心应手。视频会对常用分词方式、分词质量的评估、当前分词的困难点、分词组件源码进行讲解，让读者对分词有一个全面的认识。</p>
                <p><br></p>
                <h1><a name="lucenesousuoxiaoguo">第二个问题: lucene的搜索效果为什么好？</a></h1>
                <p>前文有说过</p>
                <p>Lucene会通过评分模型为搜索词与每一个被搜索出来商品一一计算一个相关度，相关度越大说明搜索词与商品之间的关系越大。然后商品按照与搜索词的相关度排序，和搜索词相关度大的排在前面，越靠前的商品与搜索词相关度越高，关系越大，而关键词又是用户输入的，自然靠前的商品越有可能是用户感兴趣的商品。</p>
                <p>Lucene提供了空间向量模型、BM25算法两种评分模型可以用来评估两篇文档的相关度。</p>
                <h4>用一个例子说明文章的相似度与哪些因素相关。</h4>
                <p>文档列表</p>
                <p>文档1 /www.xingkaichun.com/是/一个/学习/搜索引擎/技术/的/网站/[无命中]</p>
                <p>文档2 /制作/视频教程/很费/精力/[命中’视频教程’]</p>
                <p>文档3 /学习/视频教程/的/制作/也/很费/精力/[命中’视频教程’]</p>
                <p>文档4 /学不完/的/视频教程/[命中’视频教程’]</p>
                <p>文档5 /邢开春/是/一个/程序员/老鸟/[命中’邢开春’]</p>
                <p>文档6 /邢开春/是/一个/程序员/老鸟/邢开春/在/写/博客/[命中二次’邢开春’]</p>
                <p>文档7 /邢开春/录制/的/搜索引擎/视频教程/地址/在/www.xingkaichun.com/[命中’邢开春’、’视频教程’]</p>
                <p>文档8 /邢开春/是/一个/程序员/老鸟/邢开春/录制/的/搜索引擎/视频教程/在/www.xingkaichun.com/下载/[命中两次’邢开春’、一次’视频教程’]</p>
                <p>我想搜索邢开春出的搜索引擎教程，我输入’邢开春视频教程’进行搜索。</p>
                <p>我对搜索词做分词处理生成两个Term’邢开春’和’视频教程’，现在我们只考虑一个问题，如何比较文档与搜索词的相关度。</p>
                <h5>第一种情况:文档出不出现查询Term影响相关度。</h5>
                <p>文档1 /www.xingkaichun.com/是/一个/学习/搜索引擎/技术/的/网站/[无命中]</p>
                <p>文档2 /制作/视频教程/很费/精力/[命中’视频教程’]</p>
                <p>文档1和文档2，谁与搜索词相关度高？</p>
                <p>文档1没有命中[’邢开春’、’视频教程’]任何一个Term，而文档2命中了[’视频教程’]，很自然就可以认为文档2与搜索词相关度高。</p>
                <h5>第二种情况:文档的长度影响相关度。</h5>
                <p>文档3 /学习/视频教程/的/制作/也/很费/精力/[命中’视频教程’]</p>
                <p>文档4 /学不完/的/视频教程/[命中’视频教程’]</p>
                <p>文档3和文档4，谁与搜索词相关度高？</p>
                <p>文档3盒文档4分别命中了依次[’视频教程’]。是不是就没法比较了?</p>
                <p>文档3总共出现了7个Term;如果以被搜索出的关键词占总文档Term的比例来看，1/7；文档4总共出现了3个Term，比例为1/3;自然因为文档4关键词所占文档比例比较大，说明文档4主要内容实在说该Term，自然文档4胜利。</p>
                <h5>第三种情况:TF(Term频率)影响相关度。</h5>
                <p>文档5 /邢开春/是/一个/程序员/老鸟/[命中’邢开春’]</p>
                <p>文档6 /邢开春/是/一个/程序员/老鸟/邢开春/在/写/博客/[命中二次’邢开春’]</p>
                <p>文档5和文档6，谁与搜索词相关度高？</p>
                <p>文档5命中了一次[’邢开春’]，而文档6命中了两次[’邢开春’]。感官上来讲，文档6胜利，毕竟’邢开春’这个Term在文档6出现了两次，而文档五只出现一次。</p>
                <p>这里要引入一个概念。同一个Term在不同文章中的权重(重要性)是不同的。</p>
                <p>Term频率(Term Frequency，简称TF)是Term在文档中出现的次数。</p>
                <p>而文档中Term的TF会影响文档这个Term的权重。</p>
                <p>一般共识是Term的权重与TF成正比。</p>
                <p><br></p>
                <table class="table table-bordered">
                    <tbody>
                    <tr>
                        <td>Term<br></td>
                        <td>TF(文档5)<br></td>
                        <td>TF(文档6)<br></td>
                    </tr>
                    <tr>
                        <td>邢开春<br></td>
                        <td>1</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>是<br></td>
                        <td>1</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>一个<br></td>
                        <td>1</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>程序员<br></td>
                        <td>1</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>老鸟<br></td>
                        <td>1</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>在<br></td>
                        <td>0</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>写<br></td>
                        <td>0</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>博客<br></td>
                        <td>0</td>
                        <td>1</td>
                    </tr>
                    </tbody>
                </table>
                <h5><br>第四种情况:IDF(逆向文件频率)会影响相关度。</h5>
                <p>文档2 /制作/视频教程/很费/精力/[命中’视频教程’]</p>
                <p>文档5 /邢开春/是/一个/程序员/老鸟/[命中’邢开春’]</p>
                <p>文档2和文档5，谁与搜索词相关度高？</p>
                <p>文档2命中了[’视频教程’]，而文档5命中了[’邢开春’]。这两篇文档各命中一个不同的Term，是不是就没法比较了。</p>
                <p>各个Term的权重(重要性)是不同的。</p>
                <p>一个Term越多的出现在不同的文档中，说明这个Term越普遍，没有代表性，它的重要性就越低，毕竟物以稀为贵。例如’的’、’了’等Term，就因为在几乎每一篇文档都出现，所以它们的权重才低，甚至被用作停用词，彻底不起作用。而像’邢开春’这种Term，就只会出现在及其少的一部分文档中，因此权重才高。</p>
                <p>Term在多少个文档中出现，那么这个Term的文档频率(Document Frequency,简称DF)就是多少。文档的频率越大，Term权重越小。Term权重与文档频率成反比。</p>
                <p>‘邢开春’总计在4个文档(5/6/7/8)中出现。4是Term‘邢开春’的出现文档频率。</p>
                <p>‘视频教程’总计在5个文档(2/3/4/7/8)中出现。5是Term‘视频教程’的出现文档频率。</p>
                <p>4&lt;5。故此，权重(’邢开春’)&gt;权重(‘视频教程’)，可以简单认为文档5相比文档2更与搜索词相关。</p>
                <p>在引入一个概念，逆文档频率(Inverse Document Frequency,简称IDF)。</p>
                <p>逆文档频率，顾名思义，反向的文档频率，与文档频率成一个反比关系。文档频率越大，逆文档频率越小。文档频率越小，逆文档频率越大。Lucene里默认的IDF公式如下:</p>
                <p>IDF=log(文档总数/(DF+1))</p>
                <p>分母+1是为了避免当所有文档都不包含该Term时，分母为0的情况</p>
                <p>现在我们可以说Term的权重与文档频率成反比。也可以说Term的权重与逆文档频率成反比。同一个世界，同一个意思。</p>
                <p>而lucene提供的打分模型，VSM、BM25综合考虑了文档长度、TF、IDF等可能影响文档分值的因素。</p>
                <p>我录的视频里包含了算法的推导、源码解读、多年搜索引擎经验评分总结。.</p>
                <p>最后附上视频教程的大纲。</p>
                <p><img src="http://47.94.230.44:80/File/FileDownload?fileId=f0174a9d-cca0-45a6-aba1-7c37c92ce596" style="width: 692px;"></p>
                <p><br></p>
                <p><img src="http://47.94.230.44:80/File/FileDownload?fileId=42c90f05-6189-47d9-af6a-c896687717db" style="width: 691px;"><br></p>
			</div>
		</div>
	</div>
</body>
</html>